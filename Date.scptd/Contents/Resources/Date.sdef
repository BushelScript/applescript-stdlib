<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE dictionary SYSTEM "file://localhost/System/Library/DTDs/sdef.dtd">
<dictionary title="">
	
	
	<suite name="Date Conversion" code="****">
	
		<command name="join date" code="Dat:ReDa" description="given a record of valid year, month, day, hours, minutes, and/or seconds properties, returns a new date object">
			<direct-parameter type="date component record" optional="yes" description="all properties are optional; if omitted, default values are used instead (default: midnight of 1 January 2001)"/>
			<result type="date"/>
			<documentation>
				<html><![CDATA[
<pre><code>join date {year:2016} 
→ date "Friday, 1 January 2016 at 00:00:00"

join date {year:1990, month:June, day:15, hours:7, minutes:45}
→ date "Friday, 15 June 1990 at 07:45:00"</code></pre>

<p>For convenience, a <code>time</code> property (number of seconds since midnight) can also be used instead of <code>hours</code>, <code>minutes</code>, and <code>seconds</code>:</p>

<pre><code>join date {year:1990, month:June, day:15, time:27900}
→ date "Friday, 15 June 1990 at 07:45:00"</code></pre>
				]]></html>
			</documentation>
		</command>
		
		
		<command name="split date" code="Dat:DaRe" description="given a date object, returns a record of year, month, day, hours, minutes, and seconds properties">
			<direct-parameter type="date" optional="yes" description="(default: midnight of 1 January 2001)"/>
			<result type="date component record"/>
			<documentation>
				<html><![CDATA[
<pre><code>split date (date "Friday, 15 June 1990 at 07:45:00")
→ {year:1990, month:June, day:15, hours:7, minutes:45}</code></pre>
				]]></html>
			</documentation>
		</command>
		
		
		<record-type name="date component record" code="DatR">
			<documentation>
				<html><![CDATA[
<pre><code>{ year : <var>integer</var>,
  month : <var>integer or constant</var>,
  day : <var>integer</var>,
  hours : <var>integer</var>,
  minutes : <var>integer</var>,
  seconds : <var>integer</var> }</code></pre>
  
<p>If given, the <code>month</code> property can be a month constant (<code>January</code>, <code>February</code>, etc) or integer, while the other properties must be integers.</p>
				]]></html>
			</documentation>
		</record-type>
		
		
		<command name="parse date" code="Dat:PDat" description="parse text as a date">
			<direct-parameter type="text"/>
			<parameter name="using" code="Usin" optional="yes" description="the template text or predefined date and/or time formats to use (default: canonical date format)">
				<type type="text"/>
				<type type="FDSt" list="yes"/>
			</parameter>
			<parameter name="for locale" code="Loca" optional="yes" description="a locale identifier, e.g. “en_US” (default: no locale)">
				<type type="text"/>
				<type type="LclE"/>
			</parameter>
			<parameter name="time zone" code="TZon" optional="yes" description="if given, the date is parsed for the specified time zone (name or seconds to GMT); if omitted, the local time zone is used (TO DO: this parameter is experimental)"> <!-- TO DO: what happens if date text/date format includes TZ? -->
				<type type="text"/>
				<type type="integer"/>
			</parameter>
			<result type="date"/>
			
			<documentation>
				<html><![CDATA[
<p>By default, the <code>parse date</code> command creates a date object from canonical ISO8601-formatted text (i.e. a date in “YYYY-MM-DDTHH:MM:SS” format), for example:</p>
				
<pre><code>parse date "2016-01-07T00:41:34-0800"
→ date "Thursday, 7 January 2016 at 08:41:34"</code></pre>

<!-- TO DO: say why canonical ISO8601 format is better choice than AS's native locale- and user settings-dependent format -->

<!-- TO DO: document custom formatting options (this can be adapted from NSDateFormatter documentation) -->
				]]></html>
			</documentation>

		</command>
		
		
				
		<command name="format date" code="Dat:FDat" description="format a date as text">
			<direct-parameter type="date"/>
			<parameter name="using" code="Usin" optional="yes" description="the template text or predefined date and/or time formats to use (default: canonical date format)">
				<type type="text"/>
				<type type="FDSt"/>
			</parameter>
			<parameter name="for locale" code="Loca" optional="yes" description="a locale identifier, e.g. “en_US” (default: no locale)">
				<type type="text"/>
				<type type="LclE"/>
			</parameter>
			<parameter name="time zone" code="TZon" optional="yes" description="if given, the date is formatted for the specified time zone (name or seconds to GMT); if omitted, the local time zone is used">
				<type type="integer"/>
				<type type="text"/>
			</parameter>
			<result type="text"/>
			
			<documentation>
				<html><![CDATA[
<p>By default, the <code>format date</code> command converts a date object to canonical ISO8601-formatted text (i.e. a date in “YYYY-MM-DDTHH:MM:SS” format), for example:</p>

<pre><code>format date (date "Thursday, 7 January 2016 at 01:41:34")
→ "2016-01-07T01:41:34Z"</code></pre>

<p>By default, dates are formatted for Universal Time (a.k.a. GMT). If the <code>time zone</code> parameter is given, the date is formatted for that time zone instead:</p>

<pre><code>format date (date "Thursday, 7 January 2016 at 01:41:34") time zone (5 * hours) 
→ "2016-01-07T06:41:34+05:00"

format date (date "Thursday, 7 January 2016 at 01:41:34") time zone "Africa/Addis_Ababa"
→ "2016-01-07T04:41:34+03:00"</code></pre>

<p>To format a date for the host machine’s local time zone, use the <code>current time zone</code> command to retrieve the local time zone’s name first:</p>

<pre><code>format date (current date) time zone (current time zone)</code></pre>






<!-- TO DO: describe other constants and text templates (this can be adapted from NSDateFormatter documentation) -->
				]]></html>
			</documentation>
		</command>
		
		<enumeration name="FDSt" code="FDSt">
			<enumerator name="canonical date format" code="FDS0"/> <!-- i.e. ISO8601 -->
			<enumerator name="short date format" code="FDS1"/>
			<enumerator name="medium date format" code="FDS2"/>
			<enumerator name="long date format" code="FDS3"/>
			<enumerator name="full date format" code="FDS4"/>
			<enumerator name="short time format" code="FDS6"/>
			<enumerator name="medium time format" code="FDS7"/>
			<enumerator name="long time format" code="FDS8"/>
			<enumerator name="full time format" code="FDS9"/>
		</enumeration>
		
		<enumeration name="LclE" code="LclE">
			<!-- important: this enum must appear exactly as-is in all SDEFs that use `for locale` parameters -->
			<enumerator name="current locale" code="LclC"/>
			<enumerator name="no locale" code="LclS"/>
		</enumeration>
				
	</suite>
	
	
	
	<suite name="Date Constants" code="****">
			
		<command name="month names" code="Dat:Mths" description="returns a list of AppleScript month constants">
			<result>
				<type type="type" list="yes"/>
			</result>
		</command>
		
		<command name="weekday names" code="Dat:Wkds" description="returns a list of AppleScript weekday constants">
			<result>
				<type type="type" list="yes"/>
			</result>
		</command>
			
	</suite>
	
	
	
	<suite name="Localization Support" code="****">
				
		<command name="available locale IDs" code="Dat:LLoc" description="lists the available locale identifiers">
			<result description="e.g. {&quot;af&quot;, &quot;af_NA&quot;, &quot;af_ZA&quot;, &quot;agq&quot;, …, &quot;zu_ZA&quot;}">
				<type type="text" list="yes"/>
			</result>
		</command>
		
		
		<command name="current locale ID" code="Dat:CLoc" description="returns the locale identifier for the host machine's current locale">
			<result type="text" description="e.g. &quot;en_US&quot;"/>
		</command>
		
		
		<command name="locale info" code="Dat:LoIn" description="returns a record describing the specified locale">
			<parameter name="for" type="text" code="For_" optional="yes" description="the locale’s identifier, e.g. &quot;en_US&quot; if omitted, the current locale is used"/>
			<parameter name="in language" code="Loca" optional="yes" description="a locale identifier, e.g. “de_DE”, indicating the language in which the result should be given (default: no locale)">
				<type type="text"/>
				<type type="LclE"/>
			</parameter>
			<result type="record"/>
		
			<documentation>
				<html><![CDATA[
<pre><code>locale info for "en_GB" in language "de_DE"
→ { localeIdentifier:"en_GB", 
    localeName:"Englisch (Vereinigtes Königreich)", 
    languageCode:"en", 
    countryCode:"GB"}</code></pre>
				]]></html>
			</documentation>
		</command>

		
		
		<command name="available time zone IDs" code="Dat:LiTz" description="lists the available time zone identifiers">
			<result description="e.g. {&quot;Africa/Abidjan&quot;, &quot;Africa/Accra&quot;, &quot;Africa/Addis_Ababa&quot;, …, &quot;Pacific/Wallis&quot;}">
				<type type="text" list="yes"/>
			</result>
		</command>
		
		
		<command name="current time zone ID" code="Dat:CuTz" description="returns the identifier for the local time zone">
			<result type="text" description="e.g. &quot;America/Los_Angeles&quot;"/>
		</command>

		
		<command name="time zone info" code="Dat:TzIn" description="returns a record describing the specified time zone">
			<parameter name="for" type="text" code="For_" optional="yes" description="the time zone’s identifier, e.g. &quot;Africa/Addis_Ababa&quot; if omitted, the current time zone is used"/>
			<parameter name="in language" code="Loca" optional="yes" description="a locale identifier, e.g. “de_DE”, indicating the language in which the result should be given (default: no locale)">
				<type type="text"/>
				<type type="LclE"/>
			</parameter>
			<result type="record"/>
		
			<documentation>
				<html><![CDATA[
<pre><code>time zone info for "GMT" in language "de_DE"
→ { timeZoneID:"Europe/London", 
    secondsToGMT:0, 
    standardName:"Mittlere Greenwich-Zeit", 
    standardAbbreviation:"GMT", 
    daylightSavingName:"Britische Sommerzeit", 
    daylightSavingAbbreviation:"BST", 
    isDaylightSaving:false, 
    daylightSavingOffset:0, 
    nextDaylightSavingTransition:date "Sunday, 27 March 2016 at 02:00:00" }</code></pre>
				]]></html>
			</documentation>
		</command>
		
		
		<command name="time zone offset" code="Dat:TzOf" description="returns the number of seconds between two time zones">
			<parameter name="from" code="From" optional="yes" description="the time zone’s identifier, e.g. &quot;Africa/Addis_Ababa&quot;, or offset from GMT in seconds (default: missing value)">
				<type type="text"/>
				<type type="integer"/>
				<type type="missing value"/>
			</parameter>
			<parameter name="to" code="To__" optional="yes" description="the time zone’s identifier, e.g. &quot;America/Los_Angeles&quot;, or offset from GMT in seconds (default: missing value)">
				<type type="text"/>
				<type type="integer"/>
				<type type="missing value"/>
			</parameter>
			<result type="integer"/>
		
			<documentation>
				<html><![CDATA[
<p>If both parameters are given, the result is the number of seconds between the two time zones:</p>

<pre><code>(time zone offset from "Africa/Addis_Ababa" to "GMT") / hours 
→ 3.0 (Addis Ababa is 3 hours, or 10800 seconds, ahead of Greenwich Mean Time)

(time zone offset from "America/New_York" to "Africa/Addis_Ababa") / hours
→ -8.0 (New York is 8 hours behind Addis Ababa)</code></pre>

<p>Time zones can also be given as offsets to GMT in seconds (e.g. Central Europe is 1 hour, or 3600 seconds, ahead of GMT):</p>

<pre><code>(time zone offset from (1 * hours) to "America/New_York") / hours → 6.0</code></pre>

<p>If one parameter is given, the result is the number of seconds between that time zone and the current time zone. For example, if the current time zone is “Africa/Addis_Ababa”:</p>

<pre><code>(time zone offset from "Asia/Shanghai") / hours → 5.0

(time zone offset from "America/New_York") / hours → -8.0

(time zone offset to "America/New_York") / hours → 8.0</code></pre>

<p>If no parameters are given, the result is the number of seconds between the current time zone and GMT (equivalent to <code>time zone offset to "GMT"</code>):</p>

<pre><code>(time zone offset) / hours → 3.0</code></pre>

				]]></html>
			</documentation>
		</command>

	</suite>
	
	
</dictionary>
