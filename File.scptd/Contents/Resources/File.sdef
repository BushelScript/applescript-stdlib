<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE dictionary SYSTEM "file://localhost/System/Library/DTDs/sdef.dtd">
<dictionary>
	
	<suite name="Path Manipulation" code="****">
		
		<command name="convert path" code="Fil:ConP" description="convert file identifiers between various path formats and object types">
			<direct-parameter documentation="the file path or object to convert">
				<type type="text"/>
				<type type="file"/>
			</direct-parameter>
			<parameter name="from" code="From" type="FLCF" optional="yes" description="the direct parameter’s path format (default: POSIX file format); ignored when direct parameter is an alias/file object"/>
			<parameter name="to" code="To__" type="FLCT" optional="yes" description="the result's path format or type (default: POSIX file format)"/>
			<result documentation="the new file identifier">
				<type type="text"/>
				<type type="file"/>
			</result>
			
			<documentation>
				<html><![CDATA[
<p>Examples:</p>

<pre><code>convert path "/Users/jsmith/User Guide.txt" to HFS path format
→ "Macintosh HD:Users:jsmith:User Guide.txt"

convert path "Macintosh HD:Users:jsmith:User Guide.txt" from HFS path format
→ "/Users/jsmith/User Guide.txt"

convert path "/Users/jsmith/User Guide.txt" to alias file object
→ alias "Macintosh HD:Users:jsmith:User Guide.txt"

set theFile to POSIX file "/Users/jsmith/User Guide.txt"
convert path theFile to file URL format <i>-- (a ‘from’ parameter isn't needed here)</i>
→ "file:///Users/jsmith/User%20Guide.txt"</code></pre>
				]]></html>
			</documentation>
		</command>
		
		
		<enumeration name="FLCF" code="FLCF">
			<enumerator name="POSIX path format" code="FLCP"/>
			<enumerator name="HFS path format" code="FLCH"/>
			<enumerator name="file URL format" code="FLCU"/>
		</enumeration>
		
		<enumeration name="FLCT" code="FLCT">
			<enumerator name="POSIX path format" code="FLCP"/>
			<enumerator name="HFS path format" code="FLCH"/>
			<enumerator name="file URL format" code="FLCU"/>
			<enumerator name="alias file object" code="FLCA"/>
			<enumerator name="POSIX file object" code="FLCX"/>
			<enumerator name="file specifier object" code="FLCS"/>
		</enumeration>
		

		<command name="normalize path" code="Fil:NorP" description="">
			<direct-parameter type="text"/>
			<parameter name="full expansion" code="ExpR" type="boolean" optional="yes" description="if true, relative paths will also be expanded to absolute paths within the current folder (default: false)"/>
			<result type="text"/>
			
			<documentation>
				<html><![CDATA[
<p>Examples:</p>

<pre><code>normalize path "~/Pictures/Camera Roll/../../Movies/"
→ "/Users/jsmith/Movies"

normalize path "Music/iTunes" with full expansion
→ "/Users/jsmith/Music/iTunes"</code></pre>

<p>This command normalizes a path by performing the following clean-up tasks as needed:</p>

<ul>
<li>expanding the initial tilde expression</li>

<li>removing the initial component of “/private/var/automount”, “/var/automount”, or “/private” from the path, if the result still indicates an existing file or folder (checked by consulting the file system)</li>

<li>reducing empty components and references to the current folder (that is, the sequences “//” and “/./”) to single path separators</li>

<li>removing the trailing slash from the last component.</li>
</ul>

<p>For absolute paths, it also resolves references to the parent folder (that is, the component “..”) to the real parent folder if possible. For relative paths, references to the parent folder are left in place.</p>

<p>Note: this command will raise error number -1728 if a relative path is given and the current working directory is unknown.</p> 
				]]></html>
			</documentation>
		</command>
		
		
		<command name="join path" code="Fil:JoiP" description="given a list of path components (and/or a file name extension), joins them together to form a POSIX path">
			<direct-parameter description="the POSIX path components to join">
				<type type="text" list="yes"/>
			</direct-parameter>
			<parameter name="using file extension" code="Exte" type="text" optional="yes" description="a file name extension to append to the path (default: &quot;&quot;)"/>
			<result type="text"/>
			
			<documentation>
				<html><![CDATA[
<p>Examples:</p>

<pre><code>join path {"/", "Users", "jsmith", "Desktop"} 
→ "/Users/jsmith/Desktop"

join path {"Documents", "ReadMe"} using file extension "txt" 
→ "Documents/ReadMe.txt"

join path {POSIX file "/Users/jsmith", "Documents/ReadMe.txt"} 
→ "/Users/jsmith/Documents/ReadMe.txt"</code></pre>

<p>To construct an absolute path, the first item should be/start with &quot;/&quot; (the first item may also be an alias or file object); the remaining items are always treated as relative paths.</p>

<p>If the <code>using file extension</code> parameter is not empty, it will be added to the end of the last path component, ignoring any trailing slashes. A period separator (<code>.</code>) will be inserted automatically; do not supply it yourself.</p>
				]]></html>
			</documentation>
		</command>
		
		
		<command name="split path" code="Fil:SplP" description="Splits a POSIX path into its component parts">
			<direct-parameter type="text" description="the POSIX path to split (an alias or file object is also acceptable)"/>
			<parameter name="at" code="Upon" type="FLSP" optional="yes" description="(default: last component)"/>
			<result>
				<type type="text" list="yes"/>
			</result>
			<documentation>
				<html><![CDATA[
<p>Examples:</p>
<pre><code>set {folderPath, fileName} to split path "/Users/jsmith/Documents/ReadMe.txt"
→ {"/Users/jsmith/Documents", "ReadMe.txt"}

split path (POSIX file "/Users/jsmith/Documents/ReadMe.txt") at all components 
→ {"/", "Users", "jsmith", "Documents", "ReadMe.txt"}

split path "/Users/jsmith/Documents/ReadMe.txt" at file extension 
→ {"/Users/jsmith/Documents/ReadMe", "txt"}</code></pre>
				]]></html>
			</documentation>
		</command>
		
		
		<enumeration name="FLSP" code="FLSP">
			<enumerator name="file extension" code="FLSE"/>
			<enumerator name="last component" code="FLSL"/>
			<enumerator name="all components" code="FLSA"/>
		</enumeration>
		
		
	</suite>
	
	
	<suite name="Read/Write File" code="****">
	
		<!--TO DO: documentation should indicate legacy encodings are discouraged, especially primary encoding which is localized choice of legacy encoding so is different from user to user -->
		
		<!-- TO DO: worth noting in documentation that POSIX path strings are also accepted as direct parameter? -->
	
		<command name="read from file" code="Fil:Read" description="read a file as plain text or an AppleScript value">
			<direct-parameter type="file"/>
			<parameter name="as" code="Type" type="type" optional="yes" description="(default: text)"/>
			<parameter name="using" code="Enco" type="FEnc" optional="yes" description="when reading a plain text file, the encoding to use (default: UTF8 encoding)"/>
			<result type="anything"/>
			
			<documentation>
				<html><![CDATA[
<pre><code></code></pre>
				]]></html>
			</documentation>
		</command>
	
		<command name="write to file" code="Fil:Writ" description="write plain text or an AppleScript value to a file">
			<direct-parameter type="file"/>
			<parameter name="data" code="Data" type="anything"/>
			<parameter name="as" code="Type" type="type" optional="yes" description="(default: text)"/>
			<parameter name="using" code="Enco" type="FEnc" optional="yes" description="when writing a plain text file, the encoding to use (default: UTF8 encoding)"/>
			<result type="anything"/>
			
			<!-- note that when `as` is `text` and `using` is UTF16/32 encoding, a BOM is automatically included [by NSString's write method] -->
		</command>
		
				
		<!-- note: when defining enumerations, it is better to use a generic single-word parameter name and specific multi-word enumerator names, e.g. `using [UTF8 encoding]` rather than `using encoding [UTF8]`; since the parameter name is already scoped to the command it doesn't need to be particularly distinctive or unique, but enumerator names will be visible throughout the code so need to minimize risk of clashing with any other terminology -->
		
		<enumeration name="FEnc" code="FEnc">
			<!-- TO DO: option to determine UTF encoding from BOM, if found? (check Cocoa docs, as it may use various heuristics to determine encoding automatically) -->
			
			<!-- Unicode encodings -->
			<enumerator name="UTF8 encoding" code="FE01"/>
			
			<enumerator name="UTF16 encoding" code="FE02"/>
			<enumerator name="UTF16BE encoding" code="FE03"/>
			<enumerator name="UTF16LE encoding" code="FE04"/>
			
			<enumerator name="UTF32 encoding" code="FE05"/>
			<enumerator name="UTF32BE encoding" code="FE06"/>
			<enumerator name="UTF32LE encoding" code="FE07"/>
			
			<!-- legacy encodings -->
			<enumerator name="ASCII encoding" code="FE11"/>
			<enumerator name="ISO2022JP encoding" code="FE12"/>
			<enumerator name="ISOLatin1 encoding" code="FE13"/>
			<enumerator name="ISOLatin2 encoding" code="FE14"/>
			<enumerator name="JapaneseEUC encoding" code="FE15"/>
			<enumerator name="MacOSRoman encoding" code="FE16"/>
			<enumerator name="NonLossyASCII encoding" code="FE17"/>
			<enumerator name="ShiftJIS encoding" code="FE18"/>
			<enumerator name="Symbol encoding" code="FE19"/>
			
			<enumerator name="WindowsCP1250 encoding" code="FE50"/>
			<enumerator name="WindowsCP1251 encoding" code="FE51"/>
			<enumerator name="WindowsCP1252 encoding" code="FE52"/>
			<enumerator name="WindowsCP1253 encoding" code="FE53"/>
			<enumerator name="WindowsCP1254 encoding" code="FE54"/>
			
			<enumerator name="primary encoding" code="FEPE"/>
		</enumeration>
	
	</suite>
	
	
		
	<suite name="Shell Script Support" code="****" description="Commands used in AppleScript-based shell scripts">
		
		<command name="current working directory" code="Fil:CurF" description="Returns the host shell’s current working folder, if known">
			<result type="file"/>
			
			<documentation>
				<html><![CDATA[
<p>Useful in AppleScript-based shell scripts to obtain the shell's current working directory. For example, the following shell script processes one or more file paths supplied as arguments or, if no arguments are given, the current working directory’s path instead:</p>

<pre><code>#!/usr/bin/osascript

use script "FileLib"

to run pathsList
  if pathsList is {} then set pathsList to {(current working directory)'s POSIX path}
  repeat with pathRef in pathsList
    set aFile to (normalize path pathRef's contents with full expansion) as POSIX file
    -- process the file...
  end repeat
end run</code></pre>

<p>Throws error number -1728 if the current working directory is unknown.</p> 
				]]></html>
			</documentation>
			
		</command>
		
		
		<command name="environment variables" code="Fil:EnVa" description="Returns the host shell’s environment variables">
			<result type="record"/>
		</command>
		
		
		<command name="read from standard input" code="Fil:RSIn" description="Read the shell script’s standard input (“stdin”) as UTF8-encoded text">
			<parameter name="with prompt" code="Prmt" type="text" optional="yes" description="if ‘user interaction’ is true, the interactive line prompt to display (default: &quot;&gt;&gt; &quot;)"/>
			<parameter name="user interaction" code="ReTo" type="boolean" optional="yes" description="read a single line of text from stdin (for interactive user input), or read all stdin data (for non-interactive input from another process or file) (default: false)"/>
			<result>
				<type type="text"/>
				<type type="missing value"/>
			</result>
			<documentation>
				<html><![CDATA[
<p>If the <code>user interaction</code> option is false, the command will wait until the previous process has finished writing to the script’s stdin before returning. If it is true, it will return a line of text (minus the trailing linefeed) as soon as the Return key is pressed, or ‘missing value’ if there is no more text to be read.</p>
				]]></html>
			</documentation>
		</command>
		
		
		<command name="write to standard output" code="Fil:WSOu" description="Write UTF8-encoded text to the shell script’s standard output (“stdout”)">
			<direct-parameter type="text" description="the text to write"/>
			<parameter name="normalized line breaks" code="SLiB" type="boolean" optional="yes" description="if true, automatically converts any Windows- or classic Mac-style line breaks to Unix/OS X-style linefeeds (default: true)"/>
			<parameter name="automatic line ending" code="ALiE" type="boolean" optional="yes" description="if the text does not end with a linefeed character, add one automatically? (default: true)"/>
			<documentation>
				<html><![CDATA[
<p>Here is a simple demonstration of an interactive shell script, written in AppleScript:</p>

<pre><code>#!/usr/bin/osascript

use script "File"

write to standard output "What is your name?"
set userName to read from standard input with user interaction
if userName is "" then set userName to "stranger"
write to standard output "Hello, " &amp; userName &amp; ". How are you feeling today?"
set userMood to read from standard input with user interaction
if userMood contains "happy" or userMood contains "good" then
  write to standard output "I’m delighted to hear that."
else
  write to standard output "C’est la vie."
end if</code></pre>
				]]></html>
			</documentation>
		</command>
		
		
		<command name="parse command line arguments" code="Fil:Argv" description="Convert the shell command’s raw arguments (“argv”) into ready-to-use option and argument values">
			<direct-parameter description="the list of arguments passed to the script’s ‘run’ handler by ‘osascript’">
				<type type="text" list="yes"/>
			</direct-parameter>
			<parameter name="options" code="OpsD" optional="yes" description="a list of ‘command line option definition’ records (default: {})">
				<type type="command line option definition" list="yes"/>
			</parameter>
			<parameter name="arguments" code="OpsA" optional="yes" description="a list of ‘command line argument definition’ records (default: {{propertyName:&quot;argumentsList&quot;,valueType:text, isList:true}})">
				<type type="command line argument definition" list="yes"/>
			</parameter>
			<result type="record" description="a custom record containing all of the properties specified by the ‘options’ and ‘arguments’ parameters"/>
			<parameter name="default options" code="DefO" type="boolean" optional="yes" description="if true, default ‘-h’ (‘--help’) and ‘-v’ (‘--version’) options will be added automatically if not already defined (default: true)"/>
			<documentation>
				<html><![CDATA[
<p>An AppleScript-based shell script is saved as an uncompiled text file and has the following general form:</p>

<pre><code>#!/usr/bin/osascript

use script "FileLib"
<!--
property _name : "" -- this script’s name
-->
property _version : "" -- this script’s version (e.g. "1.2.0")

-- a short, single-line description of the shell command’s purpose:
property _summary : "" 

-- a list of zero or more ‘command line option definition’ records:
property _optionDefinitions : {} 

-- a list of zero or more ‘command line argument definition’ records:
property _argumentDefinitions : {} 

-- a multi-paragraph description of the shell command’s use:
property _description : "" 

on run argv
  set parameterRecord to (parse command line arguments argv ¬
      options _optionDefinitions arguments _argumentDefinitions)
  if parameterRecord's help then -- return help and exit
    return format command line help options _optionDefinitions ¬
        arguments _argumentDefinitions summary _summary description _description
  else if parameterRecord's |version| then -- return version and exit
    return _version
  else -- do stuff (if a value is returned, it is written to stdout)
    return doShellCommand(parameterRecord)
  end if
end run

to doShellCommand(params)
  <em>-- your code goes here…</em>
end doShellCommand</code></pre>

<p><em>TO DO: finish documentation and include examples of use (e.g. see Python's argparse documentation for comparison); these (plus the above template and following explanations of option and argument record properties) should go in separate HTML documentation within the script bundle which can then be linked here</em></p>
				]]></html>
			</documentation>
				
		</command>
		
		
		<command name="format command line help" code="Fil:FHlp" description="Generates help text suitable for logging to standard error when the ‘-h’ (‘--help’) option is given">
			<parameter name="name" code="Name" type="text" optional="yes" description="the name of the script (default: the script’s name is obtained from ‘environment variables’, if available, otherwise &quot;COMMAND&quot; is used as a placeholder)"/>
			<parameter name="summary" code="Summ" type="text" optional="yes" description="a one-line description of the command’s purpose (default: &quot;&quot;)"/>
			<parameter name="synopsis" code="Usag" optional="yes" description="one or more one-line summaries of the command’s name, options and/or arguments; if omitted, this is generated automatically (default: {})">
				<type type="text" list="yes"/>
			</parameter>
			<parameter name="options" code="OpsD" optional="yes" description="a list of ‘command line option definition’ records (default: {})">
				<type type="command line option definition" list="yes"/>
			</parameter>
			<parameter name="arguments" code="OpsA" optional="yes" description="a list of ‘command line argument definition’ records (default: {{propertyName:&quot;argumentsList&quot;,valueType:text, isList:true}})">
				<type type="command line argument definition" list="yes"/>
			</parameter>
			<parameter name="description" code="Docu" type="text" optional="yes" description="any additional documentation to be displayed (default: &quot;&quot;)"/>
			<parameter name="terminal styles" code="VFmt" type="boolean" optional="yes" description="if true, the returned text will include special formatting codes (bold, underline) to improve presentation in Terminal.app and other VT100 emulators; use false if you intend to use this text elsewhere (default: true)"/>
			<parameter name="default options" code="DefO" type="boolean" optional="yes" description="if true, default ‘-h’ (‘--help’) and ‘-v’ (‘--version’) options will be added automatically if not already defined (default: true)"/>
			<result type="text"/>
		</command>
		
		
		<record-type name="command line option definition" code="FOpD" description="The record type used by the ‘read command line arguments’ command to describe a command option">
			<documentation>
				<html><![CDATA[
<p>Each option definition consists of two or more the following record properties:</p>

<pre><code>{ propertyName : <var>text</var>,
  shortName : <var>text</var>,
  longName : <var>text</var>,
  valueType : <var>type</var>,
  isList : <var>boolean</var>,
  defaultValue : <var>any</var>,
  valuePlaceholder : <var>type</var>,
  valueDescription : <var>text</var> }</code></pre>

<p>The record must contain a <code>propertyName</code> property, plus a <code>shortName</code> and/or <code>longName</code> property. All other properties are optional.</p>

<dl>
<dt><code>propertyName</code></dt>
<dd>The name of the property that will appear in the generated options record. Property names must be unique.</dd>
<dt><code>shortName</code></dt>
<dd>A single character to be used as the option’s short name. Do not include a leading hyphen as this will be added automatically. Short names must be unique.</dd>
<dt><code>longName</code></dt>
<dd>A single word to be used as the option’s long name (camelCase words and hypenated-words are also acceptable). Do not include leading hyphens as these will be added automatically. Long names must be unique.</dd>
<dt><code>valueType</code></dt>
<dd>If the option is given, the type of its value (default: text). This should be one of: <code>boolean</code>, <code>integer</code>, <code>real</code>, <code>number</code>, <code>text</code>, <code>alias</code>, [<code>POSIX</code>] <code>file</code>. If <code>boolean</code> is used, the option does not take a value but instead changes the option’s value from false to true (or the opposite of <code>defaultValue</code>, if given).</dd>
<dt><code>isList</code></dt>
<dd>If true, the option may appear any number of times and will appear in the options record as a list of the specified type. If false, a user error will be reported if the same option appears more than once. (default: false)</dd>
<dt><code>defaultValue</code></dt>
<dd>The default value that will be added to the generated options record if the option is not given; this may be <code>missing value</code> or any of the supported value types. If omitted, and the option is not a boolean flag, a user error will be reported indicating the value is required. (default: error)</dd> <!-- note: because option definition records are stored in an NSDictionary, the default value must be an AS type that will cross the ASObjC bridge reliably, so complex types such as records, references, and script objects should be avoided; however, it's simplest and safest just to limit the user to explicitly supported types -->
<dt><code>valuePlaceholder</code></dt>
<dd>If given, a single all-uppercase word that will appear in the option description generated by <code>format command line help</code>. If omitted, a default placeholder is chosen according to <code>valueType</code> (<code>INT</code>, <code>NUM</code>, <code>TEXT</code>, <code>FILE</code>). Used by <code>format command line help</code> only.</dd>
<dt><code>valueDescription</code></dt>
<dd>If given, a single paragraph of text that will appear in the option description generated by <code>format command line help</code>. Used by <code>format command line help</code> only.</dd>
</dl>

<p>If the <code>options</code> parameter doesn’t include <code>-h</code>/<code>--help</code> and/or <code>-v</code>/<code>--version</code> definitions, default definitions will be added automatically.</p>
				]]></html>
			</documentation>
		</record-type>
		
		
		<record-type name="command line argument definition" code="FArD" description="The record type used by the ‘read command line arguments’ command to describe a matched text range">
			<documentation>
				<html><![CDATA[
<p>Each argument definition consists of one or more of the following record properties:</p>

<pre><code>{ propertyName : <var>text</var>,
  valueType : <var>type</var>,
  isList : <var>boolean</var>,
  defaultValue : <var>any</var>,
  valuePlaceholder : <var>type</var>,
  valueDescription : <var>text</var> }</code></pre>

<p>Argument definition properties have the same meaning as those in option definition records, except that they apply to any arguments that remain after the options have been parsed. The <code>propertyName</code> property is required, and should be different to the property names used by the option definitions. If the last argument definition record has an <code>isList:true</code> property, a list of all remaining arguments is assigned to that property.</p>
				]]></html>
			</documentation>
		</record-type>
		
	
	</suite>
			
</dictionary>