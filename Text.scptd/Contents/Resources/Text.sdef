<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE dictionary SYSTEM "file://localhost/System/Library/DTDs/sdef.dtd">
<dictionary>
	
	<!-- Note that while ‘verb noun’-style command names (e.g. `split text`) are strongly discouraged in application dictionaries, their use is recommended in library dictionaries to minimize the risk of collisions with user identifiers and other imported keywords (e.g. `split list`) when SDEF-based libraries are imported via global ‘use’ statements. -->
	
	<suite name="Modify Text" code="****">
		
		<command name="uppercase text" code="Txt:UppT" description="convert all alphabetical characters to uppercase">
			<direct-parameter type="text"/>
			<parameter name="for locale" code="Loca" type="text" optional="yes" description="a locale identifier, e.g. “en_US”, or “current” or “none” (default: “none”)"/>
			<result type="text"/>
			
			<documentation>
				<html><![CDATA[
<pre><code>uppercase text "foø bår" → "FOØ BÅR"</code></pre>
				]]></html>
			</documentation>
		</command>
		
		<command name="lowercase text" code="Txt:LowT" description="convert all alphabetical letters to lowercase">
			<direct-parameter type="text"/>
			<parameter name="for locale" code="Loca" type="text" optional="yes" description="a locale identifier, e.g. “en_US”, or “current” or “none” (default: “none”)"/>
			<result type="text"/>
			
			<documentation>
				<html><![CDATA[
<pre><code>lowercase text "FOØ BÅR" → "foø bår"</code></pre>
				]]></html>
			</documentation>
		</command>
		
		<command name="capitalize text" code="Txt:CapT" description="capitalize all words">
			<direct-parameter type="text"/>
			<parameter name="for locale" code="Loca" type="text" optional="yes" description="a locale identifier, e.g. “en_US”, or “current” or “none” (default: “none”)"/>
			<result type="text"/>
			
			<documentation>
				<html><![CDATA[
<pre><code>capitalize text "FOØ bår" → "Foø Bår"</code></pre>

<p>Be aware this command has only a rudimentary understanding of the complex capitalization rules used in natural languages, so results may not be as good or correct as manually capitalized text.</p>
				]]></html>
			</documentation>
		</command>
		
		
		<command name="format text" code="Txt:FTxt" description="insert a list of values into a text template">
			<direct-parameter type="text" description="the template into which to insert each item of the list"/>
			<parameter name="using" code="Usin" description="a list of values to insert (each value must be text or coercible to text)">
				<type type="text" list="yes"/>
			</parameter>
			<result type="text"/>
						
			<documentation>
				<html><![CDATA[
<pre><code>format text "Good $4, $1 $3." using {"Dr", "Jan", "Smith", "morning"}
→ "Good morning, Dr Smith."</code></pre>

<!-- TO DO: template syntax needs documented here and/or in `search text` -->
				]]></html>
			</documentation>
		</command>
		
		<command name="normalize text" code="Txt:Norm" description="eliminates variations between characters">
			<direct-parameter type="text"/>
			<parameter name="using" code="NoFo" optional="yes" description="the normalizations to apply (default: OS X line breaks)">
				<type type="NoFo"/>
			</parameter>
			<parameter name="for locale" code="Loca" type="text" optional="yes" description="a locale identifier, e.g. “en_US”, or “current” or “none” (default: “none”)"/>
			<result type="text"/>
		</command>
		
		
		<enumeration name="NoFo" code="NoFo">
			<enumerator name="normalized case" code="NoCa"/>
			<enumerator name="normalized diacriticals" code="NoDi"/>
			<enumerator name="normalized width" code="NoWi"/> <!-- TO DO: how useful is this option in practice? -->
			<enumerator name="normalized white space" code="NoSp"/>
			<enumerator name="OS X line breaks" code="LiOX"/>
			<enumerator name="Windows line breaks" code="LiWi"/>
			<enumerator name="classic Mac line breaks" code="LiCM"/>
			<enumerator name="precomposed canonical form" code="No_C"/>
			<enumerator name="decomposed canonical form" code="No_D"/>
			<enumerator name="precomposed compatibility form" code="NoKC"/>
			<enumerator name="decomposed compatibility form" code="NoKD"/>
		</enumeration>
		
		
		<command name="pad text" code="Txt:PadT" description="pad the text to a minimum length">
			<direct-parameter type="text"/>
			<parameter name="to places" code="toPl" type="integer"/>
			<parameter name="using" code="Char" type="text" optional="yes" description="(default: space)"/>
			<parameter name="adding" code="From" type="LeTr" optional="yes" description="(default: leading characters only)"/>
			<result type="text"/>
		</command>
		
		<enumeration name="LeTr" code="LeTr">
			<enumerator name="leading characters only" code="LCha"/>
			<enumerator name="trailing characters only" code="TCha"/>
			<enumerator name="leading and trailing characters" code="BCha"/>
		</enumeration>
		
		<command name="slice text" code="Txt:SliT" description="get the section of text between the specified start and/or end indexes">
			<direct-parameter type="text"/>
			<parameter name="from" code="FIdx" type="integer" optional="yes" description="character index"/>
			<parameter name="to" code="TIdx" type="integer" optional="yes" description="character index"/>
			<result type="text"/>
			<documentation>
				<html><![CDATA[
<p><code>slice text theText from i to j</code> is similar to <code>get text i thru j of theText</code>, except that it returns an empty text value if the end index is before the start index, and doesn’t throw an error if an index is out of range.</p>
				]]></html>
			</documentation>
		</command>
		
		<command name="trim text" code="Txt:TrmT" description="trim white space characters (space, tab, return, etc.) from the start and/or end of text">
			<direct-parameter type="text"/>
			<parameter name="removing" code="From" type="LeTr" optional="yes" description="(default: leading and trailing characters)"/>
			<result type="text"/>
		</command>
		
	</suite>
	
	
	
	
	<suite name="Split and Join" code="****">
	
		<command name="split text" code="Txt:SplT" description="split text using the specified separator(s)">
			<direct-parameter type="text"/>
			<parameter name="at" code="Sepa" optional="yes" description="the separator(s) upon which to split; if omitted, leading and trailing white space is trimmed and the remaining text split on contiguous white space characters">
				<type type="text"/>
				<type type="text" list="yes"/>
			</parameter>
			<parameter name="using" code="Usin" type="SerE" optional="yes" description="search using AppleScript (considering/ignoring) text comparison or ICU (regular expression) pattern matching? (default: case insensitivity)"/>
			<result>
				<type type="text" list="yes"/>
			</result>
		</command>
		
		<command name="join text" code="Txt:JoiT" description="join list of text using the specified separator">
			<direct-parameter>
				<type type="text" list="yes"/>
			</direct-parameter>
			<parameter name="using" code="Sepa" type="text" optional="yes" description="the separator(s) upon which to split (default: &quot;&quot;)"/>
			<result type="text"/>
		</command>

		<command name="split paragraphs" code="Txt:SplP" description="split text into a list of paragraphs">
			<direct-parameter type="text"/>
			<result>
				<type type="text" list="yes"/>
			</result>
		</command>

		<command name="join paragraphs" code="Txt:JoiP" description="join list of paragraphs">
			<direct-parameter>
				<type type="text" list="yes"/>
			</direct-parameter>
			<parameter name="using" code="LiBr" type="LiBr" optional="yes" description="the line break format (default: OS X line breaks)"/>
			<result type="text"/>
		</command>
		
		<enumeration name="LiBr" code="LiBr">
			<enumerator name="OS X line breaks" code="LiOX"/>
			<enumerator name="Windows line breaks" code="LiWi"/>
			<enumerator name="classic Mac line breaks" code="LiCM"/>
		</enumeration>

	</suite>
	
	
	
	
	<suite name="Find and Replace" code="****">
	
		<command name="search text" code="Txt:Srch" description="search for the specified text or pattern">
		
			<direct-parameter type="text" description="the text to search"/>
			<parameter name="for" code="For_" type="text" description="the text/pattern to find"/>
			<parameter name="replacing with" code="Repl" optional="yes" description="the replacement text/template">
				<type type="text"/>
				<type type="script"/>
			</parameter>
			
			<parameter name="using" code="Usin" type="SerE" optional="yes" description="search using AppleScript (considering/ignoring) text comparison or ICU (regular expression) pattern matching? (default: case insensitivity)"/>
			
			<parameter name="returning" code="Retu" type="RetE" optional="yes" description="if the ‘replacing with’ parameter is omitted, the type(s) of description records to return (default: matching text)"/>
			
			<result description="the modified text if the ‘replacing with’ parameter is given, otherwise a list of ‘unmatched text’ and/or ‘matched text’ records">
					<type type="text"/>
					<type type="record" list="yes"/>
			</result>
			
			<documentation>
				<html><![CDATA[
<p>When finding and replacing plain text, the ‘replacing with’ parameter can be one of the following:</p>
<ul>
	<li>the text value to insert</li>

	<li>a script object containing a <code>replaceText(foundText)</code> handler that takes the found text as its sole parameter and returns the text value to insert as its result</li>
</ul>

<p>When finding and replacing text patterns, the ‘replacing with’ parameter can be one of the following:</p>
<ul>
	<li>the text template to insert; text matched by parenthesized groups can be referred to as <code>$1</code> to <code>$9</code></li>

	<li>a script object containing a <code>replacePattern(foundText, foundGroups)</code>handler that takes the found text and a list of ‘unmatched text’ and ‘matched group’ records as its parameters and returns the text value to insert as its result</li>
</ul>

<pre><code>script ReplaceObject
  to replacePattern(theText, foundGroups)
	return "[" &amp; (uppercase text theText) &amp; "]"
  end replacePattern
end script

search text "abcdefgh" for "[aeiou]" replacing with ReplaceObject using pattern matching
→ "[A]bcd[E]fgh"</code></pre>
				]]></html>
			</documentation>

		</command>
		
		
		<enumeration name="SerE" code="SerE">
			<!-- caution: List library defines the same enums for use in its `text comparator` command, so names and codes must match exactly to avoid terminology conflicts -->
			<enumerator name="exact match" code="CmpE"/> <!-- consider everything except numeric strings -->
			<enumerator name="case sensitivity" code="CmpC"/> <!-- consider everything, including case and numeric strings -->
			<enumerator name="case insensitivity" code="CmpI"/> <!-- ignore case and consider everything else, including numeric strings -->
			<enumerator name="current considerations" code="CmpD"/> <!-- use whatever considering/ignoring settings are in effect when `search text`/`sort list` is called -->
			
			<!-- Text library also defines an enum for pattern matching -->
			<enumerator name="pattern matching" code="CmpP"/> <!-- use ICU regular expression pattern matching -->
		</enumeration>

		<enumeration name="RetE" code="RetE">
			<enumerator name="matched text only" code="MatT"/>
			<enumerator name="unmatched text only" code="UmaT"/>
			<enumerator name="matched and unmatched text" code="AllT"/>
		</enumeration>
		
		
		<command name="escape pattern" code="Txt:EPat" description="when pattern matching, escape any special characters in ‘search text’ command’s ‘for’ parameter so that they only match as literal characters">
			<direct-parameter type="text"/>
			<result type="text"/>
		</command>
		
		<command name="escape template" code="Txt:ETem" description="when pattern matching, escape any special characters in ‘search text’ command’s ‘replacing with’ parameter so that they are not substituted">
			<direct-parameter type="text"/>
			<result type="text"/>
		</command>
		
		
		<!-- record structures returned by `search text` are defined here for documentation purposes
		
			note: only the record’s type names are defined as keywords (Script Editor/OSAKit choke when displaying records that contain `class` properties whose value isn’t a type class, e.g. `{property class:"foo"}`); other properties use standard AS identifiers so can be safely used anywhere, not just inside `tell script "TextLib"...` blocks (since the record’s class property is really only included for informational purposes, e.g. when testing and debugging, it doesn’t particularly matter if its corresponding keyword isn’t always available) -->
		
		<record-type name="unmatched text" code="TxtU" description="record type used by the ‘search text’ command to describe an unmatched text range">
			<documentation>
				<html><![CDATA[
<pre><code>{ class : unmatched text,
  startIndex : <var>integer</var>,
  endIndex : <var>integer</var>,
  foundText : <var>text</var> }</code></pre>
				]]></html>
			</documentation>
		</record-type>
		
		<record-type name="matched text" code="TxtM" description="record type used by the ‘search text’ command to describe a matched text range">
			<documentation>
				<html><![CDATA[
<pre><code>{ class : matched text,
  startIndex : <var>integer</var>,
  endIndex : <var>integer</var>,
  foundText : <var>text</var>,
  foundGroups : <var>list of record</var> }</code></pre>
				]]></html>
			</documentation>
		</record-type>
		
		<record-type name="matched group" code="TxtG" description="record type used by a ‘matched text’ record’s ‘foundGroups’ property to describe the text matched by a parenthesized group within the matched pattern">
			<documentation>
				<html><![CDATA[
<pre><code>{ class : matched group,
  startIndex : <var>integer</var>,
  endIndex : <var>integer</var>,
  foundText : <var>text</var> }</code></pre>
				]]></html>
			</documentation>
		</record-type>
		
	</suite>
	
	
	
	<suite name="Regular Expression Metacharacters" code="****">
		
		
		<documentation>
			<html><![CDATA[
			
[[TO DO: note that this table is trimmed from original for length (e.g. metachars for most control codes are omitted); could probably do with trimming further if practical (), and including link to NSRegularExpression docs for any users who need the complete list]]
			
<table width="100%" style="text-align:left; margin:1em;">
	<thead>
		<tr>
			<th>Character</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>\A</code></td>
			<td>Match at the beginning of the input. Differs from <code>^</code> in that <code>\A</code> will not match after a new line within the input.</td>
		</tr>
		<tr>
			<td><code>\b</code></td>
			<td>Match if the current position is a word boundary. Word boundaries are found according to the definitions of word found in Unicode UAX 29, Text Boundaries. (Used outside of <code>[...]</code> groups.)</td>
		</tr>
		<tr>
			<td><code>\B</code></td>
			<td>Match if the current position is not a word boundary.</td>
		</tr>
		<tr>
			<td><code>\d</code></td>
			<td>Match any character with the Unicode General Category of Nd (Number, Decimal Digit.)</td>
		</tr>
		<tr>
			<td><code>\D</code></td>
			<td>Match any character that is not a decimal digit.</td>
		</tr>
		<tr>
			<td><code>\E</code></td>
			<td>Terminates a <code>\Q ... \E</code> quoted sequence.</td>
		</tr>
		<tr>
			<td><code>\G</code></td>
			<td>Match if the current position is at the end of the previous match.</td>
		</tr>
		<tr>
			<td><code>\n</code></td>
			<td>Match a <code>LINE FEED</code>, <code>\u000A</code>.</td>
		</tr>
		<tr>
			<td><code>\N{</code><em>UNICODE CHARACTER NAME</em><code>}</code></td>
			<td>Match the named character.</td>
		</tr>
		<tr>
			<td><code>\p{</code><em>UNICODE PROPERTY NAME</em><code>}</code></td>
			<td>Match any character with the specified Unicode Property.</td>
		</tr>
		<tr>
			<td><code>\P{</code><em>UNICODE PROPERTY NAME</em><code>}</code></td>
			<td>Match any character not having the specified Unicode Property.</td>
		</tr>
		<tr>
			<td><code>\Q</code></td>
			<td>Quotes all following characters until <code>\E</code>.</td>
		</tr>
		<tr>
			<td><code>\r</code></td>
			<td>Match a CARRIAGE RETURN, \u000D.</td>
		</tr>
		<tr>
			<td><code>\s</code></td>
			<td>Match a white space character. White space is defined as [\t\n\f\r\p{Z}].</td>
		</tr>
		<tr>
			<td><code>\S</code></td>
			<td>Match a non-white space character.</td>
		</tr>
		<tr>
			<td><code>\t</code></td>
			<td>Match a HORIZONTAL TAB, <code>\u0009</code>.</td>
		</tr>
		<tr>
			<td><code>\u</code><em>hhhh</em></td>
			<td>Match the character with the hex value <em>hhhh</em>.</td>
		</tr>
		<tr>
			<td><code>\U</code><em>hhhhhhhh</em></td>
			<td>Match the character with the hex value <em>hhhhhhhh</em>. Exactly eight hex digits must be provided, even though the largest Unicode code point is <code>\U0010ffff</code>.</td>
		</tr>
		<tr>
			<td><code>\w</code></td>
			<td>Match a word character. Word characters are [\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}].</td>
		</tr>
		<tr>
			<td><code>\W</code></td>
			<td>Match a non-word character.</td>
		</tr>
		<tr>
			<td><code>\x{</code><em>hhhh</em><code>}</code></td>
			<td>Match the character with hex value <em>hhhh</em>. From one to six hex digits may be supplied.</td>
		</tr>
		<tr>
			<td><code>\x</code><em>hh</em></td>
			<td>Match the character with two digit hex value <em>hh</em>.</td>
		</tr>
		<tr>
			<td><code>\X</code></td>
			<td>Match a Grapheme Cluster.</td>
		</tr>
		<tr>
			<td><code>\Z</code></td>
			<td>Match if the current position is at the end of input, but before the final line terminator, if one exists.</td>
		</tr>
		<tr>
			<td><code>\z</code></td>
			<td>Match if the current position is at the end of input.</td>
		</tr>
		<tr>
			<td><code>\</code><em>n</em></td>
			<td>Back Reference. Match whatever the <em>n</em>th capturing group matched. <em>n</em> must be a number <code>&gt; 1</code> and <code>&lt;</code> total number of capture groups in the pattern.</td>
		</tr>
		<tr>
			<td><code>[</code><em>pattern</em><code>]</code></td>
			<td>Match any one character from the pattern.</td>
		</tr>
		<tr>
			<td><code>.</code></td>
			<td>Match any character. See also the <a href="#flag-option-s"><code>s</code> flag option</a>.</td>
		</tr>
		<tr>
			<td><code>^</code></td>
			<td>Match at the beginning of a line. See also the <a href="#flag-option-m"><code>m</code> flag option</a>.</td>
		</tr>
		<tr>
			<td><code>$</code></td>
			<td>Match at the end of a line. See also the <a href="#flag-option-m"><code>m</code> flag option</a>.</td>
		</tr>
		<tr>
			<td><code>\</code></td>
			<td>Quotes the following character. Characters that must be quoted to be treated as literals are <code>* ? + [ ( ) { } ^ $ | \ . /</code></td>
		</tr>
	</tbody>
</table>

			]]></html>
		</documentation>
	</suite>
	
	
	
	<suite name="Regular Expression Operators" code="****">

		<documentation>
			<html><![CDATA[

<table width="100%" style="text-align:left; margin:1em;">
	<thead>
		<tr>
			<th>Operator</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>|</code></td>
			<td>Alternation. <em>A</em><code>|</code><em>B</em> matches either <em>A</em> or <em>B</em>.</td>
		</tr>
		<tr>
			<td><code>*</code></td>
			<td>Match <code>0</code> or more times. Match as many times as possible.</td>
		</tr>
		<tr>
			<td><code>+</code></td>
			<td>Match <code>1</code> or more times. Match as many times as possible.</td>
		</tr>
		<tr>
			<td><code>?</code></td>
			<td>Match zero or one times. Prefer one.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>}</code></td>
			<td>Match exactly <em>n</em> times.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>,}</code></td>
			<td>Match at least <em>n</em> times. Match as many times as possible.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>,</code><em>m</em><code>}</code></td>
			<td>Match between <em>n</em> and <em>m</em> times. Match as many times as possible, but not more than <em>m</em>.</td>
		</tr>
		<tr>
			<td><code>*?</code></td>
			<td>Match <code>0</code> or more times. Match as few times as possible.</td>
		</tr>
		<tr>
			<td><code>+?</code></td>
			<td>Match 1 or more times. Match as few times as possible.</td>
		</tr>
		<tr>
			<td><code>??</code></td>
			<td>Match zero or one times. Prefer zero.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>}?</code></td>
			<td>Match exactly n times.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>,}?</code></td>
			<td>Match at least n times, but no more than required for an overall pattern match.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>,</code><em>m</em><code>}?</code></td>
			<td>Match between n and m times. Match as few times as possible, but not less than n.</td>
		</tr>
		<tr>
			<td><code>*+</code></td>
			<td>Match 0 or more times. Match as many times as possible when first encountered, do not retry with fewer even if overall match fails (Possessive Match).</td>
		</tr>
		<tr>
			<td><code>++</code></td>
			<td>Match 1 or more times. Possessive match.</td>
		</tr>
		<tr>
			<td><code>?+</code></td>
			<td>Match zero or one times. Possessive match.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>}+</code></td>
			<td>Match exactly <em>n</em> times.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>,}+</code></td>
			<td>Match at least <em>n</em> times. Possessive Match.</td>
		</tr>
		<tr>
			<td><code>{</code><em>n</em><code>,</code><em>m</em><code>}+</code></td>
			<td>Match between <em>n</em> and <em>m</em> times. Possessive Match.</td>
		</tr>
		<tr>
			<td><code>(</code><em>...</em><code>)</code></td>
			<td>Capturing parentheses. Range of input that matched the parenthesized subexpression is available after the match.</td>
		</tr>
		<tr>
			<td><code>(?:</code><em>...</em><code>)</code></td>
			<td>Non-capturing parentheses. Groups the included pattern, but does not provide capturing of matching text. Somewhat more efficient than capturing parentheses.</td>
		</tr>
		<tr>
			<td><code>(?&gt;</code><em>...</em><code>)</code></td>
			<td>Atomic-match parentheses. First match of the parenthesized subexpression is the only one tried; if it does not lead to an overall pattern match, back up the search for a match to a position before the &quot;<code>(?&gt;</code>&quot;</td>
		</tr>
		<tr>
			<td><code>(?# ... )</code></td>
			<td>Free-format comment <code>(?# comment )</code>.</td>
		</tr>
		<tr>
			<td><code>(?= ... )</code></td>
			<td>Look-ahead assertion. True if the parenthesized pattern matches at the current input position, but does not advance the input position.</td>
		</tr>
		<tr>
			<td><code>(?! ... )</code></td>
			<td>Negative look-ahead assertion. True if the parenthesized pattern does not match at the current input position. Does not advance the input position.</td>
		</tr>
		<tr>
			<td><code>(?&lt;= ... )</code></td>
			<td>Look-behind assertion. True if the parenthesized pattern matches text preceding the current input position, with the last character of the match being the input character just before the current position. Does not alter the input position. The length of possible strings matched by the look-behind pattern must not be unbounded (no * or + operators.)</td>
		</tr>
		<tr>
			<td><code>(?&lt;! ... )</code></td>
			<td>Negative Look-behind assertion. True if the parenthesized pattern does not match text preceding the current input position, with the last character of the match being the input character just before the current position. Does not alter the input position. The length of possible strings matched by the look-behind pattern must not be unbounded (no * or + operators.)</td>
		</tr>
		<tr>
			<td><code>(?ismwx-ismwx:</code><code>...</code><code>)</code></td>
			<td>Flag settings. Evaluate the parenthesized expression with the specified flags enabled or -disabled. The flags are defined in Flag Options.</td>
		</tr>
		<tr>
			<td><code>(?ismwx-ismwx)</code></td>
			<td>Flag settings. Change the flag settings. Changes apply to the portion of the pattern following the setting. For example, <code>(?i)</code> changes to a case insensitive match.The flags are defined in Flag Options.</td>
		</tr>
	</tbody>
</table>
	
			]]></html>
		</documentation>
	</suite>
	
	
	
	<suite name="Flag Options" code="****">

		<documentation>
			<html><![CDATA[

<table width="100%" style="text-align:left; margin:1em;">
	<thead>
		<tr>
			<th>Option</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>i</td>
			<td>By default, matching will take place in a case-insensitive manner. Disable this option (e.g. by adding <code>(?-i)</code> to the start of the pattern text) to consider case.</td>
		</tr>
		<tr>
			<td><a id="flag-option-m"></a>m</td>
			<td>Control the behavior of &quot;<code>^</code>&quot; and &quot;<code>$</code>&quot; in a pattern. By default, &quot;<code>^</code>&quot; and &quot;<code>$</code>&quot; will match at the start and end of each line within the input text. Disable this option (e.g. by adding <code>(?-m)</code> to the start of the pattern text) to make them match the start and end of the input text only. (Alternatively, use <code>\A</code> and <code>\Z</code>/<code>\z</code> to match the start and end of the input text.)</td>
		</tr>
		<tr>
			<td><a id="flag-option-s"></a>s</td>
			<td>By default, a &quot;<code>.</code>&quot; in a pattern will match <em>any</em> character in the input text. Disable this option (e.g. by adding <code>(?-s)</code> to the start of the pattern text) to prevent it matching line terminator characters. (Also note that a <code>return</code>+<code>linefeed</code> pair representing a Windows-style line break in text is treated as a single line terminator, and will match a single &quot;<code>.</code>&quot; in a regular expression pattern.)</td>
		</tr>
		<tr>
			<td>x</td>
			<td>By default, white space characters within patterns are matched exactly. Enable this option (e.g. by adding <code>(?x)</code> to the start of the pattern text) to use white space and #comments within patterns for presentation purposes only. (White space in the input text can still be matched normally by using the corresponding metacharacters: <code>\t</code> for TAB, <code>\u0020</code> for SPACE, <code>\s</code> for any white space character, etc.)</td>
		</tr>
	</tbody>
</table>

			]]></html>
		</documentation>
	</suite>
	
	
	
	<suite name="Template Text Syntax" code="****">

		<documentation>
			<html><![CDATA[

[[TO DO: redesign template text syntax to suit `format text` command, then use modified implementation in `_replacePattern`, also updating `escape template` as appropriate ]]

			]]></html>
		</documentation>
	</suite>
	
</dictionary>

